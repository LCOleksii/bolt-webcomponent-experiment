# Web Component System Framework

## Project Architecture
```tree
${cwd}/
└── src/
    ├── [variant_template]/    # Variant template 
    ├── utils/                 # Core utilities
    │   ├── classwatcher.js    # DOM class change observer
    │   ├── customElement.js   # Web component base class
    │   └── [other utilities...]
    └── variants/
        └── {variant_name}/    # Component variation
            ├── controllers/   # Svelte logic controllers
            ├── components/    # Presentational components
            ├── App.svelte     # Root component
            ├── config.js      # Variant configuration
            └── [other files...]
```

## System Constraints
<system_constraints>
1. **Environment**: WebContainer-based Node.js runtime
2. **Dependencies**:
   - Svelte 3+ for component architecture
   - Rollup for bundling
   - Shadow DOM mandatory for component isolation
3. **File Structure**:
   - All variants must reside in `src/variants/`
   - Shared utilities must remain in `src/utils/`
4. **Code Standards**:
   - Strict separation between controllers and components
   - Config-driven component registration
   - State management through Svelte stores
</system_constraints>

## Component Development Protocol

### Core Implementation Flow
0. **Template copy**:
- Create new empty variant folder {variant_name}
- Copy [variant_template] contents to {variant_name}

1. **Configuration**:
```javascript
// src/variants/{variant_name}/config.js
export const config = {
  components: {
    "component-id": {
      view: "view-name",
      target: () => document.querySelector(".selector"),
      condition: () => true
    }
  }
}
```

2. **Component Creation**:
- `.svelte` files in `components/` for UI
- Controllers in `controllers/` for business logic

3. **View Integration**:
```svelte
<!-- App.svelte -->
{#if view === 'new-view'}
  <NewController {props}/>
{/if}
```

## Build & Deployment
<build_instructions>
1. Development: `npm run dev`
2. Production: `npm run build`
3. Testing: Use Tampermonkey config
4. Always rebuild after config changes
</build_instructions>

## Modification Standards
<code_modification_rules>
1. Use <MOD id="unique-id"> wrappers for changes
2. Preserve existing file structure
3. Follow Svelte component conventions
4. Update config.js before implementation
5. Verify Shadow DOM compatibility
</code_modification_rules>

## Critical Implementation Rules
1. **Component Isolation**:
   - Mandatory Shadow DOM usage
   - No global style leakage
   - Component-specific stores

2. **Structure Compliance**:
   - Controllers → Business logic
   - Components → Pure presentation
   - Utilities → Shared functions

3. **State Management**:
   - Use store.js for cross-component state
   - Isolate variant-specific state
   - Implement state versioning

## Example Artifact Flow
<boltArtifact id="new-variant" title="New Component Variant">
  <boltAction type="file" filePath="src/variants/new_variant/config.js">
    // Component configuration
    export const config = {
      components: {
        "new-component": {
          view: "new-view",
          target: () => document.querySelector("#target"),
          condition: () => location.host === 'example.com'
        }
      }
    }
  </boltAction>

  <boltAction type="file" filePath="src/variants/new_variant/components/NewComponent.svelte">
    <script>
      export let data;
    </script>
    
    <div class="component">{data}</div>
  </boltAction>

  <boltAction type="shell">npm run build</boltAction>
</boltArtifact>
```

**Important**: :
1. Modify and bring updates to file section <MOD></MOD>
2. Never modify file sections  <DO_NOT_MODIFY></DO_NOT_MODIFY>
3. Treat each variant root folder (e.g src/variants/new_variant) as separate application, always work on one variant modification at a time.