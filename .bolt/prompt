```markdown
# Web Component System Framework

## Project Architecture
```tree
${cwd}/
└── src/
    ├── utils/                 # Core utilities
    │   ├── classwatcher.js    # DOM class change observer
    │   ├── customElement.js   # Web component base class
    │   └── [other utilities...]
    └── variants/
        └── {variant_name}/    # Component variation
            ├── controllers/   # Svelte logic controllers
            ├── components/    # Presentational components
            ├── App.svelte     # Root component
            ├── config.js      # Variant configuration
            └── [other files...]
```

## System Constraints
<system_constraints>
1. **Environment**: WebContainer-based Node.js runtime
2. **Dependencies**:
   - Svelte 3+ for component architecture
   - Rollup for bundling
   - Shadow DOM mandatory for component isolation
3. **File Structure**:
   - All variants must reside in `src/variants/`
   - Shared utilities must remain in `src/utils/`
4. **Code Standards**:
   - Strict separation between controllers and components
   - Config-driven component registration
   - State management through Svelte stores
</system_constraints>

## Component Development Protocol

### Core Implementation Flow
1. **Configuration**:
```javascript
// src/variants/{variant_name}/config.js
export const config = {
  components: {
    "component-id": {
      view: "view-name",
      target: () => document.querySelector(".selector"),
      condition: () => true
    }
  }
}
```

2. **Component Creation**:
- `.svelte` files in `components/` for UI
- Controllers in `controllers/` for business logic

3. **View Integration**:
```svelte
<!-- App.svelte -->
{#if view === 'new-view'}
  <NewController {props}/>
{/if}
```

## Build & Deployment
<build_instructions>
1. Development: `npm run dev`
2. Production: `npm run build`
3. Testing: Use Tampermonkey config
4. Always rebuild after config changes
</build_instructions>

## Modification Standards
<code_modification_rules>
1. Use <MOD id="unique-id"> wrappers for changes
2. Preserve existing file structure
3. Follow Svelte component conventions
4. Update config.js before implementation
5. Verify Shadow DOM compatibility
</code_modification_rules>

## Critical Implementation Rules
1. **Component Isolation**:
   - Mandatory Shadow DOM usage
   - No global style leakage
   - Component-specific stores

2. **Structure Compliance**:
   - Controllers → Business logic
   - Components → Pure presentation
   - Utilities → Shared functions

3. **State Management**:
   - Use store.js for cross-component state
   - Isolate variant-specific state
   - Implement state versioning

## Example Artifact Flow
<boltArtifact id="new-variant" title="New Component Variant">
  <boltAction type="file" filePath="src/variants/new_variant/config.js">
    // Component configuration
    export const config = {
      components: {
        "new-component": {
          view: "new-view",
          target: () => document.querySelector("#target"),
          condition: () => location.host === 'example.com'
        }
      }
    }
  </boltAction>

  <boltAction type="file" filePath="src/variants/new_variant/components/NewComponent.svelte">
    <script>
      export let data;
    </script>
    
    <div class="component">{data}</div>
  </boltAction>

  <boltAction type="shell">npm run build</boltAction>
</boltArtifact>
```

## Validation Checklist
1. Shadow DOM containment verified
2. Config entries added for new components
3. All file paths match project structure
4. No global style declarations
5. Stores properly namespaced
6. Build completes without errors

**Important**: Always test component insertion lifecycle:
1. DOM target availability
2. Condition evaluation
3. View initialization
4. State synchronization
```

Key improvements made:
1. Added clear constraint categories
2. Structured modification protocols
3. Explicit validation checklist
4. Visual code block separation
5. Simplified directory structure presentation
6. Component lifecycle emphasis
7. Clear artifact flow example
8. State management guidelines
9. Build process isolation

The prompt now better guides LLM responses while maintaining project-specific requirements through:
- Structured constraint sections
- Visual code examples
- Clear modification boundaries
- Explicit validation criteria
- Component development workflow
- Artifact generation templates